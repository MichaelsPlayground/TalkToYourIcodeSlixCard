package de.androidcrypto.talktoyourntag424dnacard.lrp;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

public class CMAC {

    private static final int TAG_SIZE = 16; // Change this to match your desired tag size

    private static byte[] p64 = new byte[]{(byte)0x1b}; // for 64-bit block ciphers
    private static byte[] p128 = new byte[]{(byte)0x87}; // for 128-bit block ciphers (like AES)
    private static byte[] p256 = new byte[]{(byte)0x42, (byte)0x5}; // special for large block ciphers (Threefish)
    private static byte[] p512 = new byte[]{(byte)0x12, (byte)0x5}; // special for large block ciphers (Threefish)
    private static byte[] p1024 = new byte[]{(byte)0x8, (byte)0x4, (byte)0x3}; // special for large block ciphers (Threefish)

    private SecretKeySpec k0, k1;
    private byte[] buffer;
    private int offset;

    public CMAC(byte[] key) throws NoSuchAlgorithmException, IllegalBlockSizeException, ShortBufferException, BadPaddingException, NoSuchPaddingException {
        int blockSize = key.length;
        if (blockSize != 8 && blockSize != 16 && blockSize != 32 && blockSize != 64 && blockSize != 128) {
            throw new IllegalArgumentException("Unsupported cipher block size");
        }

        int pLen;
        byte[] p;
        if (blockSize == 8) {
            p = p64;
            pLen = 1;
        } else if (blockSize == 16) {
            p = p128;
            pLen = 1;
        } else if (blockSize == 32) {
            p = p256;
            pLen = 2;
        } else if (blockSize == 64) {
            p = p512;
            pLen = 2;
        } else {
            p = p1024;
            pLen = 3;
        }

        Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, key);

        byte[] k0 = key.getEncoded();
        byte[] k1 = Arrays.copyOf(k0, blockSize);
        byte[] buf = new byte[blockSize];

        cipher.doFinal(k0, 0, blockSize, k0, 0);

        byte v = shift(k0[blockSize - 1]);
        k0[blockSize - 1] ^= (v == 1) ? p[0] : 0;

        v = shift(k1, k0);
        k1[blockSize - 1] ^= (v == 1) ? p[0] : 0;

        return new CMAC(key, k0, k1, buf, tagSize);
    }

    public void update(byte[] msg) {
        int blockSize = k0.getEncoded().length;
        int n = msg.length;

        if (offset > 0) {
            int dif = blockSize - offset;
            if (n > dif) {
                xor(buffer, 0, msg, 0, dif);
                msg = Arrays.copyOfRange(msg, dif, n);
                cipher(buffer);
                offset = 0;
            } else {
                xor(buffer, 0, msg, 0, n);
                offset += n;
                return;
            }
        }

        if (n > blockSize) {
            int nn = n & ~(blockSize - 1);
            if (n == nn) {
                nn -= blockSize;
            }
            for (int i = 0; i < nn; i += blockSize) {
                xor(buffer, 0, msg, i, i + blockSize);
                cipher(buffer);
            }
            msg = Arrays.copyOfRange(msg, nn, n);
        }

        if (n > 0) {
            xor(buffer, offset, msg, 0, n);
            offset += n;
        }
    }

    public byte[] doFinal() {
        int blockSize = k0.getEncoded().length;

        byte[] hash = new byte[blockSize];
        byte[] k;
        if (offset < blockSize) {
            k = k1.getEncoded();
        } else {
            k = k0.getEncoded();
        }

        xor(hash, buffer, k);
        if (offset < blockSize) {
            hash[offset] ^= 0x80;
        }

        cipher(hash);

        return Arrays.copyOf(hash, TAG_SIZE);
    }

    private void cipher(byte[] data) {
        try {
            Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");
            cipher.init(Cipher.ENCRYPT_MODE, k0);
            cipher.doFinal(data, 0, k0.getEncoded().length, data, 0);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private byte shift(byte b) {
        byte result = (byte) (b >> 7);
        return (byte) (b << 1 | result);
    }

    private void xor(byte[] dst, int dstOffset, byte[] src1, int src1Offset, int src1Length) {
        for (int i = 0; i < src1Length; i++) {
            dst[dstOffset + i] ^= src1[src1Offset + i];
        }
    }

    private void xor(byte[] dst, byte[] src1, byte[] src2) {
        int length = src1.length;
        for (int i = 0; i < length; i++) {
            dst[i] = (byte) (src1[i] ^ src2[i]);
        }
    }
/*
    public static CMAC NewWithTagSize(Cipher cipher, int tagSize) throws NoSuchAlgorithmException, InvalidKeyException {
        int blockSize = cipher.getBlockSize();

        if (tagSize <= 0 || tagSize > blockSize) {
            throw new IllegalArgumentException("Invalid tag size");
        }

        byte[] p;
        switch (blockSize) {
            case 8:
                p = p64;
                break;
            case 16:
                p = p128;
                break;
            case 32:
                p = p256;
                break;
            case 64:
                p = p512;
                break;
            case 128:
                p = p1024;
                break;
            default:
                throw new NoSuchAlgorithmException("Unsupported cipher block size");
        }

        byte[] k0 = new byte[blockSize];
        byte[] k1 = new byte[blockSize];
        byte[] buf = new byte[blockSize];

        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(k0, "AES"));
        cipher.update(k0, 0, blockSize, k0, 0);

        int v = shift(k0);
        k0[blockSize - 1] ^= (byte) ((v == 1) ? p[0] : 0);

        v = shift(k1);
        k1[blockSize - 1] ^= (byte) ((v == 1) ? p[0] : 0);

        return new CMAC(new SecretKeySpec(k0, "AES"), new SecretKeySpec(k1, "AES"), buf, tagSize);
    }
  */

    public static void main(String[] args) throws NoSuchAlgorithmException {
        byte[] key = new byte[16]; // Replace with your key
        CMAC cmac = new CMAC(key);

        byte[] message = "Hello, World!".getBytes();
        cmac.update(message);

        byte[] tag = cmac.doFinal();
        System.out.println("Tag: " + bytesToHex(tag));
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder hex = new StringBuilder();
        for (byte b : bytes) {
            hex.append(String.format("%02X", b));
        }
        return hex.toString();
    }
}
